## Профилирование приложения "Трекер заявок" ##
Для профилирования приложения использовался инструментарий VisualVM 2.0.7. На первой вкладке "Обзор"
можно видеть, что приложение запущено на java 16 с минимальным размером кучи в 24 Мб и максимальным в 48 Мб.
![Обзор](../pictures/Профилирование(Обзор).jpg "VisualVM:Обзор")
----
На вкладке "Монитор" можно наблюдать такую картину: использование памяти постепенно растет до некоторого максимума,
а затем мгновенно падает примерно до 3 Мб. В этот момент резкого падения как раз и происходит сборка мусора среди молодых объектов.
![Монитор](../pictures/Профилирование(Монитор).jpg "VisualVM:Монитор")
----
Во всех подробностях этот процесс виден на вкладке "Visual GC". Объем занятой памяти в области "Eden" резко падает именно после
короткого импульса активности сборщика мусора. Здесь же можно видеть тип используемого сборщика (это G1) и заполненность областей 
памяти всех других поколений объектов. 
![VisualGC](../pictures/Профилирование(VisualGC).jpg "Visual GC")
----
При создании дампа кучи в нем можно найти статистику по используемым объектам. Например, по объектам из пакета "job4j". Здесь видно,
что в момент дампа в приложении было создано 3 объекта Item, по одному экземпляру каждого действия меню и по одному экземпляру StartUI,
MemTracker, ConsoleInput, ConsoleOutput, ValidateInput.
![Классы job4j](../pictures/Профилирование(Классы-job4j).jpg "Классы job4j")
----
## Заключение ##
Постепенный рост использования памяти происходит в то время, когда программа ждет
ввода пользователя. Очевидно, что при этом ожидании постоянно создаются какие-то новые объекты.
Если пользователь постоянно вводит данные в консоль, то такой быстрый рост количества ни к чему не привязанных объектов отсутствует.
+ В случае размер памяти, используемый программой, превышает начальный размер кучи, то размер кучи программы понемногу увеличивается до максимально допустимого.
+ Если будет превышен этот максимально допустимый размер, то происходит сборка мусора среди старого поколения объектов.
+ Если сборка мусора в области OldGen оказывается неэффективной (освобождается менее 2% памяти программы), то эта самая сборка мусора начинает выполняться слишком часто,
  что в конце концов приводит к ошибке "java.lang.OutOfMemoryError: GC overhead limit exceeded". 